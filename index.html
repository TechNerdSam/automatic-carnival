<!DOCTYPE html>
<html lang="fr" class="antialiased">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="Aetheris Architect - Expérience WebGL 3D Interactive">
    <title>AETHERIS ARCHITECT | Stable Build</title>
    
    <!-- Favicon SVG Optimisé -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 64 64%22><rect width=%2264%22 height=%2264%22 fill=%22%23050505%22/><path d=%22M14 10 H30 V18 H22 V46 H30 V54 H14 Z M50 10 H34 V18 H42 V46 H34 V54 H50 Z%22 fill=%22%23ffffff%22/><rect x=%2226%22 y=%2226%22 width=%2212%22 height=%2212%22 fill=%22%2300d9ff%22/></svg>">
    
    <!-- Préchargement des polices -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        /* --- CORE DESIGN TOKENS --- */
        :root {
            --color-void: #050505;
            --color-interface: rgba(255, 255, 255, 0.9);
            --color-success: #00ffaa;
            --color-energy: #00d9ff;
            --color-alert: #ff3e3e;
            --easing-smooth: cubic-bezier(0.22, 1, 0.36, 1);
        }

        /* --- BASE RESET & UTILS --- */
        body, html {
            background-color: var(--color-void);
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            cursor: none; /* Immersif par défaut */
            height: 100%;
            width: 100%;
        }

        /* Curseur visible sur les écrans de menu */
        body.cursor-active { cursor: auto; }

        /* --- SCANLINES & FX --- */
        #scanlines {
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%);
            background-size: 100% 4px;
            pointer-events: none;
            mix-blend-mode: overlay;
        }

        #vignette {
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.6) 100%);
            pointer-events: none;
        }

        /* --- HUD COMPONENTS --- */
        .hud-panel {
            font-family: 'JetBrains Mono', monospace;
            background: rgba(5, 5, 5, 0.6);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-left: 2px solid rgba(255,255,255,0.2);
            transition: all 0.3s ease;
        }

        .hud-text {
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        /* --- RETICLE SYSTEM --- */
        #reticle {
            transition: width 0.2s var(--easing-smooth), 
                        height 0.2s var(--easing-smooth), 
                        border-radius 0.2s var(--easing-smooth),
                        transform 0.1s linear;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        #reticle.hover {
            width: 2rem; height: 2rem;
            background: transparent;
            border: 2px solid var(--color-energy);
            border-radius: 4px;
            box-shadow: 0 0 15px var(--color-energy);
        }

        #reticle.holding {
            width: 2.5rem; height: 2.5rem;
            background: transparent;
            border: 2px solid var(--color-success);
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            box-shadow: 0 0 20px var(--color-success);
        }

        /* --- ANIMATIONS --- */
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes pulse { 0%, 100% { opacity: 0.6; } 50% { opacity: 1; } }
        
        .animate-fade-in { animation: fadeIn 1s var(--easing-smooth) forwards; }
        .animate-pulse-slow { animation: pulse 3s infinite ease-in-out; }

        /* --- LEVEL BUTTONS --- */
        .level-btn {
            transition: all 0.2s var(--easing-smooth);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .level-btn:hover {
            background: rgba(255,255,255,0.1);
            transform: translateX(5px);
            border-left-width: 4px;
        }
        
        /* --- MENU BUTTONS (PAUSE & START) --- */
        .menu-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            padding: 1rem 2rem;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            width: 100%;
            text-align: center;
        }
        
        .menu-btn:hover {
            background: white;
            color: black;
            border-color: white;
        }

        /* --- LOADING BAR --- */
        .loader-progress {
            transition: width 0.2s linear;
            box-shadow: 0 0 15px rgba(255,255,255,0.5);
        }
        
        /* --- UTILS --- */
        .blur-game {
            filter: blur(5px);
            transition: filter 0.3s ease;
        }
    </style>
</head>
<body class="cursor-active">

    <!-- FX Layers -->
    <div id="scanlines" class="fixed inset-0 z-20 opacity-30 pointer-events-none"></div>
    <div id="vignette" class="fixed inset-0 z-10 pointer-events-none"></div>
    <div id="white-fade" class="fixed inset-0 bg-white z-[90] pointer-events-none opacity-0 transition-opacity duration-[5000ms] ease-in"></div>

    <!-- UI Layer (HUD) -->
    <div id="ui-layer" class="fixed inset-0 z-30 pointer-events-none opacity-0 flex flex-col justify-between p-4 md:p-8 transition-opacity duration-1000">
        
        <!-- Top HUD -->
        <div class="flex justify-between items-start w-full">
            <div class="hud-panel p-3 md:p-4 border-l-4 !border-white">
                <div class="hud-text text-xs md:text-sm tracking-widest text-white uppercase mb-1">Objectif</div>
                <div class="text-[10px] md:text-xs text-gray-400 tracking-wider mb-2">CONNECTER NOYAUX AUX SOCLES</div>
                <div class="w-48 md:w-64 h-1 bg-white/10 rounded overflow-hidden">
                    <div id="objective-fill" class="h-full w-0 bg-[var(--color-success)] shadow-[0_0_10px_var(--color-success)] transition-all duration-500"></div>
                </div>
                <div id="objective-count" class="mt-2 text-xs font-mono text-[var(--color-success)] tracking-widest text-right">0/3</div>
            </div>

            <div class="hud-panel p-3 md:p-4 text-right">
                <div class="hud-text text-xs md:text-sm text-white tracking-widest">ARCHITECT_OS <span class="text-[var(--color-energy)]">v3.0</span></div>
                <div class="text-[10px] md:text-xs text-gray-400 mt-1">CYCLE: <span id="cycle-display" class="text-white">--</span></div>
            </div>
        </div>

        <!-- Center Reticle & Messages -->
        <div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-full text-center pointer-events-none">
            <div id="success-message" class="opacity-0 transition-opacity duration-500 transform translate-y-4">
                <h1 class="text-4xl md:text-6xl text-[var(--color-success)] font-thin tracking-[0.5em] mb-2 blur-[1px]">SYNCHRONISÉ</h1>
                <p class="text-xs md:text-sm tracking-[0.8em] text-white uppercase">Structure Stabilisée</p>
            </div>
        </div>

        <div id="reticle" class="absolute top-1/2 left-1/2 w-1 h-1 bg-white rounded-full -translate-x-1/2 -translate-y-1/2 mix-blend-exclusion"></div>

        <div id="controls-hint" class="absolute bottom-1/4 left-1/2 -translate-x-1/2 text-[10px] md:text-xs text-white/60 tracking-widest uppercase opacity-0 transition-opacity duration-300">
            [Clic Gauche] Maintenir pour saisir
        </div>

        <!-- Bottom HUD -->
        <div class="flex justify-between items-end w-full">
            <div class="hud-panel p-3 md:p-4 hidden md:block">
                <div class="hud-text text-[10px] text-gray-300 leading-relaxed">
                    [WASD/ZQSD] MOUVEMENT<br>
                    [ESPACE] SAUT<br>
                    [SOURIS] ORIENTATION<br>
                    [ÉCHAP] PAUSE
                </div>
            </div>
            
            <div class="hud-panel p-3 md:p-4 text-right">
                <div class="hud-text text-[10px] md:text-xs text-gray-400">
                    FPS: <span id="fps-counter" class="text-white">60</span><br>
                    PHYSIQUE: <span class="text-[var(--color-success)]">ACTIVE</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Pause Screen -->
    <div id="pause-screen" class="hidden fixed inset-0 z-[60] bg-black/80 backdrop-blur-sm flex flex-col items-center justify-center animate-fade-in">
        <div class="w-full max-w-sm flex flex-col gap-4 p-8 border border-white/10 bg-black/50">
            <h2 class="text-3xl text-white font-thin tracking-[0.5em] text-center mb-8 border-b border-white/20 pb-4">PAUSE</h2>
            
            <button id="resume-btn" class="menu-btn">
                Reprendre
            </button>
            
            <button id="restart-btn" class="menu-btn">
                Recommencer Cycle
            </button>
            
            <button id="menu-return-btn" class="menu-btn border-red-500/30 text-red-100 hover:text-red-500 hover:border-red-500">
                Menu Principal
            </button>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="fixed inset-0 z-50 bg-[#050505]/95 backdrop-blur-xl flex flex-col items-center justify-center transition-opacity duration-500">
        
        <div id="boot-sequence" class="flex flex-col items-center text-center max-w-lg px-4">
            <h1 class="text-5xl md:text-7xl font-thin tracking-[0.3em] text-white mb-8 animate-fade-in select-none">AETHERIS</h1>
            
            <div id="mobile-warning" class="hidden mb-6 p-4 border border-yellow-500/30 bg-yellow-500/10 rounded text-yellow-200 text-xs tracking-widest text-left">
                ⚠️ ATTENTION: Ce terminal nécessite un clavier et une souris pour naviguer dans l'architecture. L'expérience tactile n'est pas supportée.
            </div>

            <button id="init-btn" class="group relative px-8 py-4 bg-white/5 border border-white/20 hover:bg-white hover:text-black hover:border-white transition-all duration-300 animate-fade-in" style="animation-delay: 0.2s">
                <span class="font-mono tracking-[0.2em] text-sm md:text-base uppercase">Initialiser le Système</span>
                <div class="absolute inset-0 bg-white/10 scale-x-0 group-hover:scale-x-100 transition-transform origin-left duration-300"></div>
            </button>

            <div id="loader-container" class="hidden w-64 mt-8">
                <div class="h-0.5 bg-gray-800 w-full overflow-hidden relative">
                    <div id="loader-bar" class="h-full bg-white w-0 absolute top-0 left-0"></div>
                </div>
                <p id="loading-text" class="font-mono text-[10px] text-gray-500 mt-2 tracking-widest animate-pulse-slow">INITIALISATION DU MOTEUR PHYSIQUE...</p>
                <p id="error-text" class="hidden font-mono text-[10px] text-[var(--color-alert)] mt-2 tracking-widest"></p>
            </div>
        </div>

        <div id="level-selector" class="hidden flex-col items-center w-full max-w-6xl px-4 md:px-8 h-[80vh] animate-fade-in">
            <h2 class="text-xl md:text-2xl text-white tracking-[0.5em] mb-8 border-b border-white/10 pb-4 w-full text-center font-light">SÉLECTION DU PROTOCOLE</h2>
            <div id="level-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 w-full overflow-y-auto pr-2 custom-scrollbar">
                <!-- JS Generated -->
            </div>
        </div>
    </div>

    <!-- Transition Screen -->
    <div id="cycle-screen" class="fixed inset-0 z-40 bg-black flex flex-col items-center justify-center opacity-0 pointer-events-none transition-opacity duration-500">
        <h1 class="text-3xl md:text-5xl font-light tracking-[0.3em] text-white mb-4 text-center">CYCLE TERMINÉ</h1>
        <p class="font-mono text-sm text-[var(--color-energy)] tracking-widest animate-pulse">RECONFIGURATION DE L'ARCHITECTURE...</p>
    </div>

    <!-- Ending Screen -->
    <div id="ending-screen" class="hidden fixed inset-0 z-[100] bg-white flex flex-col items-center justify-center opacity-0 transition-opacity duration-[2000ms]">
        <h1 class="text-6xl md:text-8xl font-thin tracking-[0.1em] text-black mb-2 animate-fade-in">AETHERIS</h1>
        <p class="text-sm md:text-xl tracking-[0.4em] text-gray-500 uppercase mb-12 animate-fade-in" style="animation-delay: 1s">Architecture Complète</p>
        
        <div class="text-center space-y-8 animate-fade-in" style="animation-delay: 2s">
            <div>
                <p class="text-xs font-bold text-black uppercase tracking-widest mb-1">Conception & Code</p>
                <p class="text-base text-gray-600 font-light">Samyn-Antoy ABASSE</p>
            </div>
            <div>
                <p class="text-xs font-bold text-black uppercase tracking-widest mb-1">Production</p>
                <p class="text-base text-gray-600 font-light">TechNerdSam Interactive</p>
            </div>
        </div>

        <button onclick="location.reload()" class="mt-16 px-8 py-3 border border-black text-black hover:bg-black hover:text-white transition-colors duration-300 font-mono tracking-widest text-sm uppercase opacity-0 animate-fade-in" style="animation-delay: 4s; animation-fill-mode: forwards;">
            Réinitialiser
        </button>
    </div>

    <!-- Import Map pour la stabilité des versions -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
                "@dimforge/rapier3d-compat": "https://unpkg.com/@dimforge/rapier3d-compat@0.12.0/rapier.es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import RAPIER from '@dimforge/rapier3d-compat';

        /* --- CONFIGURATION & CONSTANTES --- */
        const CONFIG = {
            fov: 80,
            renderDistance: 500,
            playerSpeed: 12.0,
            playerJump: 18.0, 
            gravity: { x: 0.0, y: -30.0, z: 0.0 },
            grabDistance: 15.0, 
            holdDistance: 4.0,  
            magnetRadius: 4.0,  
            maxCycles: 7,
            colors: {
                success: 0x00ffaa,
                void: 0x050505
            }
        };

        const CYCLES_DATA = [
            { fog: 0x081015, light: 0xaaccff, accent: 0x00d9ff, concrete: 0x505055, name: "INITIATION" },
            { fog: 0x051505, light: 0xccffcc, accent: 0x00ff88, concrete: 0x445544, name: "JARDIN" },
            { fog: 0x151005, light: 0xffddaa, accent: 0xffaa00, concrete: 0x555044, name: "RUINES" },
            { fog: 0x100515, light: 0xccaaff, accent: 0xaa00ff, concrete: 0x504455, name: "RÊVE" },
            { fog: 0x150505, light: 0xffaaaa, accent: 0xff0044, concrete: 0x554444, name: "DANGER" },
            { fog: 0x000000, light: 0x888888, accent: 0xffffff, concrete: 0x222222, name: "NÉANT" },
            { fog: 0xeeeeee, light: 0xffffff, accent: 0x000000, concrete: 0xffffff, name: "LUMIÈRE" }
        ];

        /* --- AUDIO MANAGER (Robuste) --- */
        class AudioManager {
            constructor() {
                this.ctx = null;
                this.masterGain = null;
                this.initialized = false;
            }

            async init() {
                if (this.initialized) return;
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.value = 0.5; // Protection oreilles
                    this.masterGain.connect(this.ctx.destination);
                    this.createAmbience();
                    this.initialized = true;
                    if(this.ctx.state === 'suspended') await this.ctx.resume();
                } catch (e) {
                    console.warn("Audio init failed:", e);
                }
            }

            createAmbience() {
                if(!this.ctx) return;
                const bufferSize = 2 * this.ctx.sampleRate;
                const noiseBuffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                
                let lastOut = 0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    output[i] = (lastOut + (0.02 * white)) / 1.02;
                    lastOut = output[i];
                    output[i] *= 3.5; 
                }
                
                const node = this.ctx.createBufferSource();
                node.buffer = noiseBuffer;
                node.loop = true;
                const gain = this.ctx.createGain();
                gain.gain.value = 0.03;
                node.connect(gain);
                gain.connect(this.masterGain);
                node.start();
            }

            playTone(type) {
                if (!this.initialized || !this.ctx) return;
                const t = this.ctx.currentTime;
                
                if (type === 'grab') {
                    const osc = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    osc.frequency.setValueAtTime(200, t);
                    osc.frequency.exponentialRampToValueAtTime(600, t + 0.2);
                    g.gain.setValueAtTime(0.05, t);
                    g.gain.linearRampToValueAtTime(0, t + 0.2);
                    osc.connect(g); g.connect(this.masterGain);
                    osc.start(); osc.stop(t + 0.3);
                } 
                else if (type === 'success') {
                    [440, 554, 659].forEach((f, i) => {
                        const osc = this.ctx.createOscillator();
                        const g = this.ctx.createGain();
                        osc.frequency.value = f;
                        g.gain.setValueAtTime(0, t);
                        g.gain.linearRampToValueAtTime(0.05, t + 0.1 + (i*0.05));
                        g.gain.exponentialRampToValueAtTime(0.001, t + 3);
                        osc.connect(g); g.connect(this.masterGain);
                        osc.start(); osc.stop(t + 3);
                    });
                }
                else if (type === 'cycle') {
                    const osc = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(110, t);
                    osc.frequency.linearRampToValueAtTime(55, t + 2);
                    g.gain.setValueAtTime(0.1, t);
                    g.gain.exponentialRampToValueAtTime(0.001, t + 4);
                    const f = this.ctx.createBiquadFilter();
                    f.frequency.setValueAtTime(1000, t);
                    f.frequency.exponentialRampToValueAtTime(100, t + 2);
                    osc.connect(f); f.connect(g); g.connect(this.masterGain);
                    osc.start(); osc.stop(t + 4);
                }
                else if (type === 'ending') {
                    const freqs = [220, 277.18, 329.63, 440, 554.37, 880];
                    freqs.forEach((f, i) => {
                        const osc = this.ctx.createOscillator();
                        const g = this.ctx.createGain();
                        osc.frequency.value = f;
                        g.gain.setValueAtTime(0, t);
                        g.gain.linearRampToValueAtTime(0.05, t + 2 + (i*0.5));
                        g.gain.exponentialRampToValueAtTime(0.001, t + 10);
                        osc.connect(g); g.connect(this.masterGain);
                        osc.start(); osc.stop(t + 12);
                    });
                }
            }
        }

        /* --- MATERIAL FACTORY --- */
        class MaterialFactory {
            constructor() {
                this.store = {};
            }

            updatePalette(palette) {
                // Disposal des anciens matériaux si nécessaire (pour la mémoire)
                this.store = {
                    concrete: new THREE.MeshStandardMaterial({
                        color: palette.concrete,
                        roughness: 0.9,
                        metalness: 0.2,
                        flatShading: true,
                    }),
                    core: new THREE.MeshPhysicalMaterial({
                        color: palette.accent,
                        metalness: 0.1,
                        roughness: 0.2,
                        transmission: 0.6,
                        thickness: 1.5,
                        emissive: palette.accent,
                        emissiveIntensity: 0.4
                    }),
                    socket: new THREE.MeshStandardMaterial({
                        color: 0x222222,
                        emissive: 0x000000,
                        roughness: 0.5,
                        metalness: 0.8
                    }),
                    accentColor: palette.accent
                };
            }
        }

        /* --- GAME ENGINE (Core) --- */
        class GameEngine {
            constructor() {
                this.state = 'MENU'; // MENU, PLAYING, PAUSED, TRANSITION, ENDING
                this.container = document.body;
                this.clock = new THREE.Clock();
                this.audio = new AudioManager();
                this.mats = new MaterialFactory();
                
                // Physics
                this.world = null;
                this.playerBody = null;
                this.characterController = null;
                
                // Scene
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                
                // Game Data
                this.objects = [];
                this.sockets = [];
                this.cores = [];
                this.currentCycle = 1;
                this.score = 0;
                
                // Interaction
                this.raycaster = new THREE.Raycaster();
                this.heldObject = null;
                this.input = { up: false, down: false, left: false, right: false, jump: false, click: false };
                this.velY = 0;

                // Bindings
                this.loop = this.loop.bind(this);
                this.onResize = this.onResize.bind(this);
                this.onKeyDown = this.onKeyDown.bind(this);
                this.onKeyUp = this.onKeyUp.bind(this);
                this.onMouseDown = this.onMouseDown.bind(this);
                this.onMouseUp = this.onMouseUp.bind(this);
            }

            /* --- INITIALIZATION --- */
            async boot() {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                if (isMobile) document.getElementById('mobile-warning').style.display = 'block';

                document.getElementById('init-btn').addEventListener('click', async () => {
                    document.getElementById('init-btn').style.display = 'none';
                    const loader = document.getElementById('loader-container');
                    const bar = document.getElementById('loader-bar');
                    loader.style.display = 'block';

                    try {
                        // 1. Audio Init (Requires user gesture)
                        await this.audio.init();
                        bar.style.width = '30%';

                        // 2. Physics Init (Async)
                        await RAPIER.init();
                        this.world = new RAPIER.World(CONFIG.gravity);
                        bar.style.width = '70%';

                        // 3. Graphics Init
                        this.initGraphics();
                        this.initInputs();
                        this.initPauseMenu();
                        bar.style.width = '100%';

                        // 4. Launch Menu
                        setTimeout(() => this.showLevelSelect(), 500);

                    } catch (err) {
                        console.error(err);
                        document.getElementById('loading-text').style.display = 'none';
                        const errTxt = document.getElementById('error-text');
                        errTxt.innerText = "ERREUR CRITIQUE: " + err.message;
                        errTxt.style.display = 'block';
                    }
                });
            }

            initGraphics() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(CONFIG.colors.void);
                this.scene.fog = new THREE.FogExp2(CONFIG.colors.void, 0.02);

                this.camera = new THREE.PerspectiveCamera(CONFIG.fov, window.innerWidth / window.innerHeight, 0.1, CONFIG.renderDistance);
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Perf cap
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.container.appendChild(this.renderer.domElement);

                // Lighting
                this.hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
                this.scene.add(this.hemiLight);

                this.dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
                this.dirLight.position.set(30, 80, 40);
                this.dirLight.castShadow = true;
                this.dirLight.shadow.mapSize.set(2048, 2048);
                // Optimisation shadow volume
                const d = 100;
                this.dirLight.shadow.camera.left = -d;
                this.dirLight.shadow.camera.right = d;
                this.dirLight.shadow.camera.top = d;
                this.dirLight.shadow.camera.bottom = -d;
                this.scene.add(this.dirLight);

                window.addEventListener('resize', this.onResize);
                
                // Controls logic updated for Pause
                this.controls = new PointerLockControls(this.camera, document.body);
                
                this.controls.addEventListener('lock', () => {
                    if (this.state === 'PAUSED') {
                        // Returning from pause
                        this.togglePause(false);
                    } else if (this.state === 'MENU') {
                         this.state = 'PLAYING';
                         document.getElementById('ui-layer').style.opacity = '1';
                         document.getElementById('start-screen').style.display = 'none';
                         document.body.classList.remove('cursor-active');
                    }
                });

                this.controls.addEventListener('unlock', () => {
                    // Si on est en train de jouer et qu'on déverrouille (Echap), on met en pause
                    if (this.state === 'PLAYING') {
                        this.togglePause(true);
                    } else if (this.state !== 'ENDING' && this.state !== 'TRANSITION' && this.state !== 'PAUSED') {
                        document.body.classList.add('cursor-active');
                    }
                });
            }
            
            initPauseMenu() {
                // Binding buttons
                document.getElementById('resume-btn').onclick = () => {
                    this.controls.lock(); // This triggers 'lock' event which sets state to PLAYING
                };
                
                document.getElementById('restart-btn').onclick = () => {
                    this.loadLevel(this.currentCycle);
                    this.controls.lock();
                    this.togglePause(false);
                };
                
                document.getElementById('menu-return-btn').onclick = () => {
                    this.togglePause(false);
                    this.clearLevel();
                    this.state = 'MENU';
                    
                    document.getElementById('pause-screen').style.display = 'none';
                    document.getElementById('ui-layer').style.opacity = '0';
                    document.getElementById('start-screen').style.display = 'flex';
                    this.showLevelSelect();
                    document.body.classList.add('cursor-active');
                };
            }
            
            togglePause(isPaused) {
                const pauseScreen = document.getElementById('pause-screen');
                const ui = document.getElementById('ui-layer');
                
                if (isPaused) {
                    this.state = 'PAUSED';
                    pauseScreen.style.display = 'flex';
                    ui.classList.add('blur-game');
                    document.body.classList.add('cursor-active');
                } else {
                    this.state = 'PLAYING';
                    pauseScreen.style.display = 'none';
                    ui.classList.remove('blur-game');
                    document.body.classList.remove('cursor-active');
                    this.clock.getDelta(); // Reset clock delta to prevent jump
                }
            }

            initInputs() {
                document.addEventListener('keydown', this.onKeyDown);
                document.addEventListener('keyup', this.onKeyUp);
                document.addEventListener('mousedown', this.onMouseDown);
                document.addEventListener('mouseup', this.onMouseUp);
            }

            /* --- LEVEL LOGIC --- */
            showLevelSelect() {
                const ui = document.getElementById('boot-sequence');
                const selector = document.getElementById('level-selector');
                const grid = document.getElementById('level-grid');
                
                ui.style.display = 'none';
                selector.style.display = 'flex';
                grid.innerHTML = '';

                CYCLES_DATA.forEach((cycle, idx) => {
                    const btn = document.createElement('div');
                    btn.className = "level-btn bg-white/5 p-4 cursor-pointer flex justify-between items-center group relative overflow-hidden";
                    
                    const hex = '#' + cycle.accent.toString(16).padStart(6, '0');
                    
                    btn.innerHTML = `
                        <div class="relative z-10">
                            <div class="font-mono text-xs text-gray-500 mb-1 group-hover:text-white transition-colors">CYCLE_0${idx + 1}</div>
                            <div class="text-sm md:text-base text-white tracking-widest uppercase font-light">${cycle.name}</div>
                        </div>
                        <div class="text-xl relative z-10 transition-transform group-hover:translate-x-1" style="color: ${hex}">►</div>
                        <div class="absolute inset-0 bg-gradient-to-r from-transparent to-[${hex}] opacity-0 group-hover:opacity-10 transition-opacity duration-300"></div>
                    `;
                    btn.onclick = () => this.loadLevel(idx + 1);
                    grid.appendChild(btn);
                });
            }

            clearLevel() {
                // Cleanup Physics
                if (this.heldObject) this.releaseObject();
                this.objects.forEach(obj => {
                    if(obj.mesh) {
                        this.scene.remove(obj.mesh);
                        if(obj.mesh.geometry) obj.mesh.geometry.dispose();
                    }
                    if(obj.body) this.world.removeRigidBody(obj.body);
                });
                if(this.playerBody) {
                    this.world.removeRigidBody(this.playerBody);
                    this.world.removeCharacterController(this.characterController);
                }

                this.objects = [];
                this.sockets = [];
                this.cores = [];
                this.score = 0;
                
                // UI Reset
                document.getElementById('objective-fill').style.width = '0%';
                document.getElementById('objective-count').innerText = '0/3';
                document.getElementById('success-message').classList.remove('opacity-100');
                document.getElementById('success-message').classList.add('opacity-0');
            }

            loadLevel(index) {
                this.clearLevel();
                this.currentCycle = index;
                this.state = 'PLAYING';
                
                // Setup Environment
                const data = CYCLES_DATA[index - 1];
                this.mats.updatePalette(data);
                
                this.scene.background.setHex(data.fog);
                this.scene.fog.color.setHex(data.fog);
                this.dirLight.color.setHex(data.light);
                this.hemiLight.color.setHex(data.light);
                
                document.documentElement.style.setProperty('--color-energy', '#' + data.accent.toString(16).padStart(6, '0'));
                document.getElementById('cycle-display').innerText = `${index} / ${CONFIG.maxCycles}`;

                // Init Player
                const bodyDesc = RAPIER.RigidBodyDesc.kinematicPositionBased().setTranslation(0, 5, 0);
                this.playerBody = this.world.createRigidBody(bodyDesc);
                const collider = RAPIER.ColliderDesc.capsule(0.5, 0.4);
                this.world.createCollider(collider, this.playerBody);
                this.characterController = this.world.createCharacterController(0.1);
                this.characterController.enableAutostep(0.7, 0.3, true);
                this.characterController.enableSnapToGround(0.5);
                this.characterController.setMaxSlopeClimbAngle(50 * Math.PI / 180);

                this.buildArchitecture(index);

                // UI Transitions
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('cycle-screen').style.opacity = '0';
                this.controls.lock();
                
                if (!this.clock.running) {
                    this.clock.start();
                    this.loop();
                }
            }

            buildArchitecture(cycle) {
                // Helpers
                const addWall = (x, z, w, h, d) => {
                    const geo = new THREE.BoxGeometry(w, h, d);
                    const mesh = new THREE.Mesh(geo, this.mats.store.concrete);
                    mesh.position.set(x, h/2, z);
                    mesh.castShadow = true; mesh.receiveShadow = true;
                    this.scene.add(mesh);
                    
                    const body = this.world.createRigidBody(RAPIER.RigidBodyDesc.fixed().setTranslation(x, h/2, z));
                    this.world.createCollider(RAPIER.ColliderDesc.cuboid(w/2, h/2, d/2), body);
                    this.objects.push({ mesh, body });
                };

                // Floor
                const floorGeo = new THREE.BoxGeometry(160, 2, 160);
                const floorMesh = new THREE.Mesh(floorGeo, this.mats.store.concrete);
                floorMesh.position.y = -1; floorMesh.receiveShadow = true;
                this.scene.add(floorMesh);
                const floorBody = this.world.createRigidBody(RAPIER.RigidBodyDesc.fixed().setTranslation(0, -1, 0));
                this.world.createCollider(RAPIER.ColliderDesc.cuboid(80, 1, 80), floorBody);
                this.objects.push({ mesh: floorMesh, body: floorBody });

                // Boundaries
                addWall(0, -80, 160, 20, 10); addWall(0, 80, 160, 20, 10);
                addWall(-80, 0, 10, 20, 160); addWall(80, 0, 10, 20, 160);

                // Level Spec
                let sockets = [], spawns = [];
                switch(cycle) {
                    case 1:
                        sockets = [{x:0, z:15}, {x:-15, z:0}, {x:15, z:0}];
                        spawns = [{x:0, z:-10}, {x:-10, z:-10}, {x:10, z:-10}];
                        break;
                    case 2:
                        addWall(0, 0, 20, 6, 20);
                        sockets = [{x:30, z:30}, {x:-30, z:30}, {x:0, z:-40}];
                        spawns = [{x:30, z:-30}, {x:-30, z:-30}, {x:0, z:40}];
                        break;
                    case 3:
                        addWall(-20, 0, 5, 8, 60); addWall(20, 0, 5, 8, 60);
                        sockets = [{x:0, z:50}, {x:-40, z:0}, {x:40, z:0}];
                        spawns = [{x:0, z:-30}, {x:-40, z:20}, {x:40, z:20}];
                        break;
                    case 4:
                        addWall(0, 20, 80, 6, 5); addWall(0, -20, 80, 6, 5);
                        sockets = [{x:50, z:0}, {x:-50, z:0}, {x:0, z:50}];
                        spawns = [{x:0, z:0}, {x:20, z:0}, {x:-20, z:0}];
                        break;
                    case 5:
                        addWall(25, 25, 5, 8, 20); addWall(40, 15, 20, 8, 5);
                        addWall(-25, -25, 5, 8, 20); addWall(-40, -15, 20, 8, 5);
                        addWall(10, -10, 4, 12, 4); addWall(-10, 10, 4, 12, 4);
                        sockets = [{x:35, z:35}, {x:-35, z:-35}, {x:0, z:0}];
                        spawns = [{x:0, z:40}, {x:0, z:-40}, {x:0, z:0}];
                        break;
                    case 6:
                        addWall(0, 30, 20, 30, 20); addWall(-50, 0, 10, 20, 10); addWall(50, 0, 10, 20, 10);
                        sockets = [{x:0, z:-40}, {x:-40, z:20}, {x:40, z:20}];
                        spawns = [{x:0, z:50}, {x:-50, z:-10}, {x:50, z:-10}];
                        break;
                    case 7:
                        for(let z=-40; z<=40; z+=20) { addWall(20, z, 2, 10, 2); addWall(-20, z, 2, 10, 2); }
                        sockets = [{x:0, z:30}, {x:0, z:0}, {x:0, z:-30}];
                        spawns = [{x:5, z:30}, {x:-5, z:0}, {x:5, z:-30}];
                        break;
                    default:
                        sockets = [{x:0, z:10}, {x:10, z:-10}, {x:-10, z:-10}]; spawns = [{x:0,z:0},{x:0,z:0},{x:0,z:0}];
                }

                // Place Interactive Elements
                for(let i=0; i<3; i++) {
                    // Socket
                    const sp = sockets[i] || {x: i*10, z:0};
                    const sGeo = new THREE.CylinderGeometry(3.5, 3.5, 0.4, 32);
                    const sMesh = new THREE.Mesh(sGeo, this.mats.store.socket.clone());
                    sMesh.position.set(sp.x, 0.2, sp.z); sMesh.receiveShadow = true;
                    this.scene.add(sMesh);

                    // Beam
                    const bGeo = new THREE.ConeGeometry(3, 60, 32, 1, true);
                    const bMat = new THREE.MeshBasicMaterial({ color: this.mats.store.accentColor, transparent: true, opacity: 0.1, side: THREE.DoubleSide, blending: THREE.AdditiveBlending, depthWrite: false });
                    const beam = new THREE.Mesh(bGeo, bMat);
                    beam.position.set(sp.x, 30, sp.z);
                    this.scene.add(beam);

                    this.sockets.push({ mesh: sMesh, beam, pos: new THREE.Vector3(sp.x, 1, sp.z), active: false });
                    this.objects.push({ mesh: sMesh, body: null }, { mesh: beam, body: null });

                    // Core
                    const cp = spawns[i] || {x:0, z:0};
                    const cGeo = new THREE.BoxGeometry(1.5, 1.5, 1.5);
                    const cMesh = new THREE.Mesh(cGeo, this.mats.store.core.clone());
                    cMesh.position.set(cp.x, 5, cp.z); cMesh.castShadow = true;
                    cMesh.add(new THREE.PointLight(this.mats.store.accentColor, 2, 8));
                    this.scene.add(cMesh);

                    const cBody = this.world.createRigidBody(RAPIER.RigidBodyDesc.dynamic().setTranslation(cp.x, 5, cp.z).setLinearDamping(2.0).setAngularDamping(2.0).setCanSleep(false));
                    this.world.createCollider(RAPIER.ColliderDesc.cuboid(0.75, 0.75, 0.75).setRestitution(0.1).setFriction(2.0).setDensity(5.0), cBody);

                    this.cores.push({ mesh: cMesh, body: cBody, locked: false });
                    this.objects.push({ mesh: cMesh, body: cBody });
                }
            }

            /* --- GAMEPLAY LOOP --- */
            loop() {
                requestAnimationFrame(this.loop);
                
                // Always render scene even when paused (prevents black screen)
                if (this.state === 'PAUSED') {
                    this.renderer.render(this.scene, this.camera);
                    return;
                }
                
                const dt = Math.min(this.clock.getDelta(), 0.1); // Clamp dt for safety
                if(this.state !== 'PLAYING' && this.state !== 'ENDING') return;

                // Physics Step
                this.world.step();

                // 1. Update Player
                if (this.state === 'PLAYING') {
                    const dir = new THREE.Vector3();
                    const fwd = new THREE.Vector3();
                    const right = new THREE.Vector3();
                    
                    this.camera.getWorldDirection(fwd); fwd.y = 0; fwd.normalize();
                    right.crossVectors(fwd, new THREE.Vector3(0,1,0)).normalize();

                    if(this.input.up) dir.add(fwd);
                    if(this.input.down) dir.sub(fwd);
                    if(this.input.right) dir.add(right);
                    if(this.input.left) dir.sub(right);

                    if(dir.lengthSq() > 0) dir.normalize().multiplyScalar(CONFIG.playerSpeed * dt);

                    const grounded = this.characterController.computedGrounded();
                    if(grounded) {
                        this.velY = -2.0;
                        if(this.input.jump) this.velY = CONFIG.playerJump;
                    } else {
                        this.velY += CONFIG.gravity.y * dt * 2.0;
                    }

                    this.characterController.computeColliderMovement(this.world.getCollider(this.playerBody.collider(0)), { x: dir.x, y: this.velY * dt, z: dir.z });
                    const m = this.characterController.computedMovement();
                    const pos = this.playerBody.translation();
                    this.playerBody.setNextKinematicTranslation({ x: pos.x + m.x, y: pos.y + m.y, z: pos.z + m.z });
                    this.camera.position.set(pos.x + m.x, pos.y + m.y + 0.8, pos.z + m.z);

                    // Grab Interaction
                    if(this.input.click && !this.heldObject) this.tryGrab();
                    if(!this.input.click && this.heldObject) this.releaseObject();
                    this.updateHeldObject(dt);
                    this.updateReticle();
                }

                // 2. Sync Objects
                this.cores.forEach(c => {
                    if (!c.locked) {
                        const t = c.body.translation();
                        const r = c.body.rotation();
                        c.mesh.position.set(t.x, t.y, t.z);
                        c.mesh.quaternion.set(r.x, r.y, r.z, r.w);
                        this.checkMagnetism(c);
                    }
                });

                // 3. Ending Animation
                if (this.state === 'ENDING' && this.endingParticles) {
                    this.endingParticles.rotation.y += 0.001;
                    this.endingParticles.position.y += 0.1;
                    this.camera.position.y += 0.05;
                }

                this.renderer.render(this.scene, this.camera);
            }

            /* --- INTERACTION --- */
            tryGrab() {
                this.raycaster.setFromCamera(new THREE.Vector2(0,0), this.camera);
                const candidates = this.cores.filter(c => !c.locked).map(c => c.mesh);
                const hits = this.raycaster.intersectObjects(candidates);
                
                if(hits.length > 0 && hits[0].distance < CONFIG.grabDistance) {
                    const core = this.cores.find(c => c.mesh === hits[0].object || c.mesh === hits[0].object.parent);
                    if(core) {
                        this.heldObject = core;
                        this.audio.playTone('grab');
                        document.getElementById('reticle').classList.add('holding');
                        core.body.wakeUp();
                    }
                }
            }

            releaseObject() {
                if(this.heldObject) {
                    this.heldObject = null;
                    document.getElementById('reticle').classList.remove('holding');
                }
            }

            updateHeldObject(dt) {
                if(!this.heldObject) return;
                const target = new THREE.Vector3();
                this.camera.getWorldDirection(target);
                target.multiplyScalar(CONFIG.holdDistance).add(this.camera.position);
                
                const current = this.heldObject.body.translation();
                const dist = new THREE.Vector3(target.x - current.x, target.y - current.y, target.z - current.z);
                
                if (dist.length() > 10) { this.releaseObject(); return; }
                
                dist.multiplyScalar(800 * dt);
                this.heldObject.body.setLinvel({x: dist.x, y: dist.y, z: dist.z}, true);
                this.heldObject.body.setAngvel({x:0, y:0, z:0}, true);
                this.heldObject.body.setRotation({x:0, y:0, z:0, w:1}, true);
            }

            checkMagnetism(core) {
                if(this.heldObject === core) return;
                
                let bestSocket = null;
                let minDist = CONFIG.magnetRadius;

                this.sockets.forEach(s => {
                    if(s.active) return;
                    const d = core.mesh.position.distanceTo(s.pos);
                    if(d < minDist) { minDist = d; bestSocket = s; }
                });

                if(bestSocket) {
                    const cPos = core.body.translation();
                    const dir = new THREE.Vector3(bestSocket.pos.x - cPos.x, bestSocket.pos.y - cPos.y, bestSocket.pos.z - cPos.z).normalize();
                    core.body.applyImpulse({x: dir.x*0.5, y: -0.1, z: dir.z*0.5}, true);

                    if(minDist < 1.5) {
                        // Success Lock
                        core.locked = true;
                        bestSocket.active = true;
                        this.score++;
                        
                        core.body.setBodyType(RAPIER.RigidBodyType.Fixed);
                        core.body.setTranslation(bestSocket.pos, true);
                        core.body.setRotation({x:0,y:0,z:0,w:1}, true);
                        core.mesh.position.copy(bestSocket.pos);
                        core.mesh.rotation.set(0,0,0);
                        
                        // Visuals
                        const successColor = CONFIG.colors.success;
                        core.mesh.material.color.setHex(successColor);
                        core.mesh.material.emissive.setHex(successColor);
                        core.mesh.material.emissiveIntensity = 1;
                        bestSocket.beam.material.color.setHex(successColor);
                        bestSocket.beam.material.opacity = 0.5;

                        this.audio.playTone('success');
                        
                        // UI Update
                        const pct = (this.score / 3) * 100;
                        document.getElementById('objective-fill').style.width = `${pct}%`;
                        document.getElementById('objective-count').innerText = `${this.score}/3`;
                        
                        if(this.score >= 3) this.completeLevel();
                    }
                }
            }

            updateReticle() {
                if(this.heldObject) return;
                this.raycaster.setFromCamera(new THREE.Vector2(0,0), this.camera);
                const candidates = this.cores.filter(c => !c.locked).map(c => c.mesh);
                const hits = this.raycaster.intersectObjects(candidates);
                const r = document.getElementById('reticle');
                const h = document.getElementById('controls-hint');
                
                if(hits.length > 0 && hits[0].distance < CONFIG.grabDistance) {
                    r.classList.add('hover');
                    h.classList.remove('opacity-0');
                } else {
                    r.classList.remove('hover');
                    h.classList.add('opacity-0');
                }
            }

            completeLevel() {
                document.getElementById('success-message').classList.remove('opacity-0');
                document.getElementById('success-message').classList.add('opacity-100');
                
                if (this.currentCycle >= CONFIG.maxCycles) {
                    setTimeout(() => this.triggerEnding(), 2000);
                } else {
                    setTimeout(() => {
                        this.state = 'TRANSITION';
                        this.audio.playTone('cycle');
                        const screen = document.getElementById('cycle-screen');
                        screen.style.opacity = '1';
                        
                        setTimeout(() => {
                            this.loadLevel(this.currentCycle + 1);
                            screen.style.opacity = '0';
                        }, 3000);
                    }, 2000);
                }
            }

            triggerEnding() {
                this.state = 'ENDING';
                this.controls.unlock();
                document.getElementById('ui-layer').style.opacity = '0';
                this.audio.playTone('ending');
                this.world.gravity = {x:0, y:0.5, z:0}; // Zero-G ascent

                // Particles
                const geo = new THREE.BufferGeometry();
                const pos = [];
                for(let i=0; i<2000; i++) pos.push((Math.random()-0.5)*100, Math.random()*50, (Math.random()-0.5)*100);
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                const mat = new THREE.PointsMaterial({color: 0xffffff, size:0.2, transparent:true, opacity:0.8});
                this.endingParticles = new THREE.Points(geo, mat);
                this.scene.add(this.endingParticles);

                // Fade to White
                document.getElementById('white-fade').classList.remove('opacity-0');
                setTimeout(() => {
                    document.getElementById('ending-screen').style.display = 'flex';
                    // Petit délai pour permettre au display flex de s'appliquer avant l'opacité
                    requestAnimationFrame(() => {
                         document.getElementById('ending-screen').classList.remove('opacity-0');
                    });
                }, 5000);
            }

            /* --- EVENT HANDLERS --- */
            onResize() {
                if(!this.camera || !this.renderer) return;
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            onKeyDown(e) {
                switch(e.code) {
                    case 'KeyW': case 'ArrowUp': this.input.up = true; break;
                    case 'KeyS': case 'ArrowDown': this.input.down = true; break;
                    case 'KeyA': case 'ArrowLeft': this.input.left = true; break;
                    case 'KeyD': case 'ArrowRight': this.input.right = true; break;
                    case 'Space': this.input.jump = true; break;
                }
            }

            onKeyUp(e) {
                switch(e.code) {
                    case 'KeyW': case 'ArrowUp': this.input.up = false; break;
                    case 'KeyS': case 'ArrowDown': this.input.down = false; break;
                    case 'KeyA': case 'ArrowLeft': this.input.left = false; break;
                    case 'KeyD': case 'ArrowRight': this.input.right = false; break;
                    case 'Space': this.input.jump = false; break;
                }
            }

            onMouseDown(e) { if(e.button === 0) this.input.click = true; }
            onMouseUp(e) { if(e.button === 0) this.input.click = false; }
        }

        // --- BOOTSTRAP ---
        window.addEventListener('DOMContentLoaded', () => {
            const game = new GameEngine();
            window.game = game; // Debug access
            game.boot();
        });

    </script>
</body>
</html>
